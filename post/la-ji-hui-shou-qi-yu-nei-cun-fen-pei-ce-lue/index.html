<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>垃圾回收器与内存分配策略 | daugraph</title>
<link rel="shortcut icon" href="https://daugraph.github.io//favicon.ico?v=1617710699249">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://daugraph.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="垃圾回收器与内存分配策略 | daugraph - Atom Feed" href="https://daugraph.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="生存还是死亡？
即使在可达性分析算法中判定为不可达对象，也是“非死不可”的，这时候它们暂时还处于“缓行”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://daugraph.github.io/">
  <img class="avatar" src="https://daugraph.github.io//images/avatar.png?v=1617710699249" alt="">
  </a>
  <h1 class="site-title">
    daugraph
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              垃圾回收器与内存分配策略
            </h2>
            <div class="post-info">
              <span>
                2021-03-29
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="生存还是死亡">生存还是死亡？</h3>
<p>即使在可达性分析算法中判定为不可达对象，也是“非死不可”的，这时候它们暂时还处于“缓行”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ul>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。加入对象没有override finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”；</li>
<li>如果这个对象被判定为有必要执行finalize()  方法，那么该对象将被放置在一个名为 F-Queue的队列中，并在稍后由一条虚拟机自动建立的、低调度等优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会出发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的fianlize() 方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。如果要在finalize() 方法中拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把this关键字赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合。</li>
</ul>
<p>对象自救实例：</p>
<pre><code class="language-java">public class FinalizeEscapeGC {

    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.out.println(&quot;yes, i am still alive :)&quot;);
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;finalize method executed !&quot;);
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws InterruptedException {
        SAVE_HOOK = new FinalizeEscapeGC();

        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;no, i am dead :(&quot;);
        }

        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;no, i am dead :(&quot;);
        }

    }
}
</code></pre>
<h3 id="回收方法区">回收方法区</h3>
<p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法中实现垃圾回收，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在。<br>
方法区的垃圾回收主要回收两部分内容：废弃的常量和不再使用的类型。<br>
回收废弃的常量与回收Java堆中的对象非常类似，不再赘述。<br>
判断类型可以回收需要同时满足的条件：</p>
<ul>
<li>该类所有的实例都已经被回收（也就是Java堆中不存在该类及其任何派生类子类的实例）</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<p>从如何判定对象消亡的角度出发，垃圾回收算法可以划分为“引用计数式垃圾收集器（Reference Counting GC）”和“追踪式垃圾收集器（Tracing GC）”两大类，这两类被称作“直接垃圾收集”和“间接垃圾收集”，主流的Java虚拟机中都没有涉及到“引用计数垃圾收集器”。</p>
<h3 id="分代收集理论">分代收集理论</h3>
<p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序实际运行情况的经验法则，它建立在两个分代假说上：</p>
<ul>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象朝生夕灭</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过多次GC的对象越难以消亡</li>
</ul>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的设计原则：收集器应该将堆划分出不同的区域，然后将回收对象根据其年龄分配到不同的区域中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保存少量存活而不是去标记大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那么把它们集中在一起，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存空间的有效利用。</p>
<p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因此才有了Minor GC、Major GC、Full GC这样的回收类型的划分；也才能够针对不同的区域设计不同的垃圾回收算法——因此发展出了标记-复制、标记-清除、标记-整理等针对性的垃圾回收算法。所有的这一切都始于分代收集理论。</p>
<p>第三个分代假说：</p>
<ul>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
<p>存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长后晋升到老年代中，这时跨代引用也随即被消除了。</p>
<h3 id="标记-清除算法">标记-清除算法</h3>
<p>这是最早出现也是最基础的垃圾回收算法，在1960年由Lisp之父 John McCarthy 所提出。首先标记出所有需要回收的对象，再统一回收掉被标记的对象，也可以反过来。</p>
<p>缺点：</p>
<ul>
<li>执行效率不稳定：如果Java堆中存在大量需要被回收的对象(死亡对象)，必须进行大量标记和清除动作，导致标记和清除两个过程的执行效率都随着对象数量增长而降低；</li>
<li>内存空间碎片化：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<h3 id="标记-复制算法">标记-复制算法</h3>
<p>为了解决标记-清除算法面对大量可回收对象执行效率低，1969年Fenichel提出了一种称为半区复制的垃圾收集算法，它将可用内存划分为大小相等的两块。1989年Andrew Appel提出了更优化的半区复制分代策略，现在称为Appel式回收。Hotspot虚拟机中的Serial、ParNew</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1">生存还是死亡？</a></li>
<li><a href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA">回收方法区</a></li>
</ul>
</li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">垃圾回收算法</a>
<ul>
<li><a href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA">分代收集理论</a></li>
<li><a href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">标记-清除算法</a></li>
<li><a href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">标记-复制算法</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://daugraph.github.io/post/outofmemroyerror-yi-chang/">
              <h3 class="post-title">
                OutOfMemroyError异常
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://daugraph.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
